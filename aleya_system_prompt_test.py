#!/usr/bin/env python3
"""
Enhanced System Prompt Testing for –ê–ª–µ—Å—è - Belarus Constitution AI Assistant
Specifically tests the enhanced system prompt for –ê–ª–µ—Å—è focusing on:
1. Identity and Role Testing
2. Constitution Knowledge Testing  
3. Non-Constitution Refusal Testing
4. Article Reference Testing
5. Voice Mode API Testing with Enhanced Prompt
"""

import asyncio
import aiohttp
import json
import uuid
import time
from datetime import datetime
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv('/app/frontend/.env')

# Get backend URL from environment variable
BACKEND_URL = os.environ.get('REACT_APP_BACKEND_URL', 'http://localhost:8001')
BASE_API_URL = f"{BACKEND_URL}/api"

print(f"Testing –ê–ª–µ—Å—è enhanced system prompt at: {BASE_API_URL}")

class AleyaSystemPromptTester:
    def __init__(self):
        self.session = None
        self.test_session_id = str(uuid.uuid4())
        self.results = {
            'identity_role_testing': {'passed': False, 'details': []},
            'constitution_knowledge': {'passed': False, 'details': []},
            'non_constitution_refusal': {'passed': False, 'details': []},
            'article_references': {'passed': False, 'details': []},
            'voice_mode_session': {'passed': False, 'details': []},
            'backend_logging': {'passed': False, 'details': []},
            'system_prompt_length': {'passed': False, 'details': []}
        }

    async def setup(self):
        """Initialize HTTP session"""
        self.session = aiohttp.ClientSession()

    async def cleanup(self):
        """Close HTTP session"""
        if self.session:
            await self.session.close()

    async def test_identity_and_role(self):
        """Test Identity and Role Testing - Questions like '–ö—Ç–æ —Ç—ã?', '–†–∞—Å—Å–∫–∞–∂–∏ –æ —Å–µ–±–µ', etc."""
        print("\nüß™ Testing Identity and Role Recognition...")
        
        identity_questions = [
            "–ö—Ç–æ —Ç—ã?",
            "–†–∞—Å—Å–∫–∞–∂–∏ –æ —Å–µ–±–µ",
            "–ö–∞–∫–∞—è —Ç–≤–æ—è —Ä–æ–ª—å?",
            "–ß—Ç–æ —Ç—ã –∑–Ω–∞–µ—à—å?"
        ]
        
        passed_tests = 0
        total_tests = len(identity_questions)
        
        for question in identity_questions:
            try:
                payload = {
                    "session_id": f"{self.test_session_id}_identity",
                    "message": question
                }
                
                async with self.session.post(f"{BASE_API_URL}/chat", json=payload) as response:
                    if response.status == 200:
                        data = await response.json()
                        response_text = data.get('response', '').lower()
                        
                        # Check for –ê–ª–µ—Å—è identity markers
                        aleya_markers = [
                            '–∞–ª–µ—Å—è',
                            '–≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç',
                            '–∫–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏—è —Ä–µ—Å–ø—É–±–ª–∏–∫–∏ –±–µ–ª–∞—Ä—É—Å—å',
                            '–∫–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏—è –±–µ–ª–∞—Ä—É—Å–∏'
                        ]
                        
                        markers_found = sum(1 for marker in aleya_markers if marker in response_text)
                        
                        if markers_found >= 2:  # Should mention at least 2 key identity markers
                            passed_tests += 1
                            self.results['identity_role_testing']['details'].append(f"‚úÖ '{question}' - –ê–ª–µ—Å—è properly identified herself ({markers_found}/4 markers)")
                            print(f"‚úÖ '{question}' - Identity confirmed")
                        else:
                            self.results['identity_role_testing']['details'].append(f"‚ùå '{question}' - Insufficient identity markers ({markers_found}/4)")
                            print(f"‚ùå '{question}' - Identity unclear: {response_text[:100]}...")
                    else:
                        self.results['identity_role_testing']['details'].append(f"‚ùå '{question}' - HTTP {response.status}")
                        print(f"‚ùå '{question}' - Request failed: {response.status}")
                        
            except Exception as e:
                self.results['identity_role_testing']['details'].append(f"‚ùå '{question}' - Exception: {str(e)}")
                print(f"‚ùå '{question}' - Error: {str(e)}")
        
        if passed_tests >= 3:  # At least 3 out of 4 should pass
            self.results['identity_role_testing']['passed'] = True
            print(f"‚úÖ Identity and Role Testing: {passed_tests}/{total_tests} passed")
        else:
            print(f"‚ùå Identity and Role Testing: {passed_tests}/{total_tests} passed (need at least 3)")
        
        return passed_tests >= 3

    async def test_constitution_knowledge(self):
        """Test Constitution Knowledge Testing - Specific Constitution questions"""
        print("\nüß™ Testing Constitution Knowledge...")
        
        constitution_questions = [
            "–ö–∞–∫–∏–µ –ø—Ä–∞–≤–∞ –≥—Ä–∞–∂–¥–∞–Ω –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏—è –ë–µ–ª–∞—Ä—É—Å–∏?",
            "–†–∞—Å—Å–∫–∞–∂–∏ –æ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –≤–ª–∞—Å—Ç–∏ –ø–æ –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–∏",
            "–ß—Ç–æ –≥–æ–≤–æ—Ä–∏—Ç –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏—è –æ –ø—Ä–∞–≤–∞—Ö —á–µ–ª–æ–≤–µ–∫–∞?",
            "–ö–∞–∫–∏–µ –æ–±—è–∑–∞–Ω–Ω–æ—Å—Ç–∏ –≥—Ä–∞–∂–¥–∞–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–µ–π?",
            "–ß—Ç–æ —Å–∫–∞–∑–∞–Ω–æ –≤ –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–∏ –æ –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–µ–Ω–Ω–æ–º —è–∑—ã–∫–µ?"
        ]
        
        passed_tests = 0
        total_tests = len(constitution_questions)
        
        for question in constitution_questions:
            try:
                payload = {
                    "session_id": f"{self.test_session_id}_constitution",
                    "message": question
                }
                
                async with self.session.post(f"{BASE_API_URL}/chat", json=payload) as response:
                    if response.status == 200:
                        data = await response.json()
                        response_text = data.get('response', '')
                        
                        # Check for Constitution-specific content
                        constitution_markers = [
                            '–∫–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏—è',
                            '—Å—Ç–∞—Ç—å—è',
                            '—Å—Ç–∞—Ç—å–∏',
                            '—Ä–µ—Å–ø—É–±–ª–∏–∫–∏ –±–µ–ª–∞—Ä—É—Å—å',
                            '–±–µ–ª–∞—Ä—É—Å–∏'
                        ]
                        
                        markers_found = sum(1 for marker in constitution_markers if marker.lower() in response_text.lower())
                        
                        # Check response length (should be substantial for Constitution questions)
                        if len(response_text) > 100 and markers_found >= 2:
                            passed_tests += 1
                            self.results['constitution_knowledge']['details'].append(f"‚úÖ '{question[:50]}...' - Detailed Constitution response ({len(response_text)} chars, {markers_found} markers)")
                            print(f"‚úÖ Constitution question answered with detail")
                        else:
                            self.results['constitution_knowledge']['details'].append(f"‚ùå '{question[:50]}...' - Insufficient detail ({len(response_text)} chars, {markers_found} markers)")
                            print(f"‚ùå Constitution question - insufficient detail")
                    else:
                        self.results['constitution_knowledge']['details'].append(f"‚ùå '{question[:50]}...' - HTTP {response.status}")
                        print(f"‚ùå Constitution question failed: {response.status}")
                        
            except Exception as e:
                self.results['constitution_knowledge']['details'].append(f"‚ùå '{question[:50]}...' - Exception: {str(e)}")
                print(f"‚ùå Constitution question error: {str(e)}")
        
        if passed_tests >= 4:  # At least 4 out of 5 should pass
            self.results['constitution_knowledge']['passed'] = True
            print(f"‚úÖ Constitution Knowledge Testing: {passed_tests}/{total_tests} passed")
        else:
            print(f"‚ùå Constitution Knowledge Testing: {passed_tests}/{total_tests} passed (need at least 4)")
        
        return passed_tests >= 4

    async def test_non_constitution_refusal(self):
        """Test Non-Constitution Refusal Testing - Test refusal behavior"""
        print("\nüß™ Testing Non-Constitution Question Refusal...")
        
        non_constitution_questions = [
            "–ö–∞–∫–∞—è –ø–æ–≥–æ–¥–∞ —Å–µ–≥–æ–¥–Ω—è?",
            "–†–∞—Å—Å–∫–∞–∂–∏ –æ –∑–∞–∫–æ–Ω–∞—Ö –†–æ—Å—Å–∏–∏",
            "–ö–∞–∫ –ø—Ä–∏–≥–æ—Ç–æ–≤–∏—Ç—å –±–æ—Ä—â?",
            "–ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ –º–∏—Ä–µ?",
            "–†–∞—Å—Å–∫–∞–∂–∏ –∞–Ω–µ–∫–¥–æ—Ç"
        ]
        
        expected_refusal_phrases = [
            "–º–µ–Ω—è –∑–æ–≤—É—Ç –∞–ª–µ—Å—è",
            "–º–æ–≥—É –æ—Ç–≤–µ—á–∞—Ç—å —Ç–æ–ª—å–∫–æ",
            "–∫–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–∏ —Ä–µ—Å–ø—É–±–ª–∏–∫–∏ –±–µ–ª–∞—Ä—É—Å—å",
            "–∫–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–∏ –±–µ–ª–∞—Ä—É—Å–∏",
            "–ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å –æ –∫–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–∏"
        ]
        
        passed_tests = 0
        total_tests = len(non_constitution_questions)
        
        for question in non_constitution_questions:
            try:
                payload = {
                    "session_id": f"{self.test_session_id}_refusal",
                    "message": question
                }
                
                async with self.session.post(f"{BASE_API_URL}/chat", json=payload) as response:
                    if response.status == 200:
                        data = await response.json()
                        response_text = data.get('response', '').lower()
                        
                        # Check for proper refusal message
                        refusal_markers_found = sum(1 for phrase in expected_refusal_phrases if phrase in response_text)
                        
                        if refusal_markers_found >= 2:  # Should have at least 2 refusal markers
                            passed_tests += 1
                            self.results['non_constitution_refusal']['details'].append(f"‚úÖ '{question}' - Properly refused ({refusal_markers_found} markers)")
                            print(f"‚úÖ Non-Constitution question properly refused")
                        else:
                            self.results['non_constitution_refusal']['details'].append(f"‚ùå '{question}' - Improper refusal ({refusal_markers_found} markers): {response_text[:100]}...")
                            print(f"‚ùå Non-Constitution question - improper refusal")
                    else:
                        self.results['non_constitution_refusal']['details'].append(f"‚ùå '{question}' - HTTP {response.status}")
                        print(f"‚ùå Non-Constitution question failed: {response.status}")
                        
            except Exception as e:
                self.results['non_constitution_refusal']['details'].append(f"‚ùå '{question}' - Exception: {str(e)}")
                print(f"‚ùå Non-Constitution question error: {str(e)}")
        
        if passed_tests >= 4:  # At least 4 out of 5 should pass
            self.results['non_constitution_refusal']['passed'] = True
            print(f"‚úÖ Non-Constitution Refusal Testing: {passed_tests}/{total_tests} passed")
        else:
            print(f"‚ùå Non-Constitution Refusal Testing: {passed_tests}/{total_tests} passed (need at least 4)")
        
        return passed_tests >= 4

    async def test_article_references(self):
        """Test Article Reference Testing - Verify responses include specific article numbers"""
        print("\nüß™ Testing Article Reference Inclusion...")
        
        article_specific_questions = [
            "–ß—Ç–æ –≥–æ–≤–æ—Ä–∏—Ç —Å—Ç–∞—Ç—å—è 24 –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–∏?",
            "–†–∞—Å—Å–∫–∞–∂–∏ –æ —Å—Ç–∞—Ç—å–µ 33 –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–∏ –ë–µ–ª–∞—Ä—É—Å–∏",
            "–ö–∞–∫–∏–µ –ø—Ä–∞–≤–∞ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç —Å—Ç–∞—Ç—å—è 25?",
            "–ß—Ç–æ —Å–∫–∞–∑–∞–Ω–æ –≤ —Å—Ç–∞—Ç—å–µ 50 –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–∏?",
            "–†–∞—Å—Å–∫–∞–∂–∏ –æ –ø—Ä–∞–≤–∞—Ö –≥—Ä–∞–∂–¥–∞–Ω –ø–æ –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–∏"  # Should reference multiple articles
        ]
        
        passed_tests = 0
        total_tests = len(article_specific_questions)
        
        for question in article_specific_questions:
            try:
                payload = {
                    "session_id": f"{self.test_session_id}_articles",
                    "message": question
                }
                
                async with self.session.post(f"{BASE_API_URL}/chat", json=payload) as response:
                    if response.status == 200:
                        data = await response.json()
                        response_text = data.get('response', '').lower()
                        
                        # Check for article references
                        article_patterns = [
                            '—Å—Ç–∞—Ç—å—è',
                            '—Å—Ç–∞—Ç—å–∏',
                            '—Å—Ç–∞—Ç—å–µ',
                            '—Å—Ç–∞—Ç—å—é'
                        ]
                        
                        # Check for specific article numbers
                        import re
                        article_numbers = re.findall(r'—Å—Ç–∞—Ç—å[—è–µ–∏—é]\s*(\d+)', response_text)
                        
                        article_references = sum(1 for pattern in article_patterns if pattern in response_text)
                        
                        if article_references > 0 and (len(article_numbers) > 0 or '—Å–ø—Ä–∞–≤–∫–∞:' in response_text):
                            passed_tests += 1
                            self.results['article_references']['details'].append(f"‚úÖ '{question[:40]}...' - Article references found ({article_references} refs, numbers: {article_numbers})")
                            print(f"‚úÖ Article references included")
                        else:
                            self.results['article_references']['details'].append(f"‚ùå '{question[:40]}...' - No article references ({article_references} refs, numbers: {article_numbers})")
                            print(f"‚ùå No article references found")
                    else:
                        self.results['article_references']['details'].append(f"‚ùå '{question[:40]}...' - HTTP {response.status}")
                        print(f"‚ùå Article reference question failed: {response.status}")
                        
            except Exception as e:
                self.results['article_references']['details'].append(f"‚ùå '{question[:40]}...' - Exception: {str(e)}")
                print(f"‚ùå Article reference question error: {str(e)}")
        
        if passed_tests >= 3:  # At least 3 out of 5 should pass
            self.results['article_references']['passed'] = True
            print(f"‚úÖ Article Reference Testing: {passed_tests}/{total_tests} passed")
        else:
            print(f"‚ùå Article Reference Testing: {passed_tests}/{total_tests} passed (need at least 3)")
        
        return passed_tests >= 3

    async def test_voice_mode_session_creation(self):
        """Test Voice Mode API Testing - Session creation with enhanced prompt"""
        print("\nüß™ Testing Voice Mode Session Creation with Enhanced Prompt...")
        
        try:
            # Test session creation endpoint
            async with self.session.post(f"{BASE_API_URL}/voice/realtime/session") as response:
                if response.status == 200:
                    data = await response.json()
                    
                    # Check if session data contains expected fields
                    if 'client_secret' in data or 'session_id' in data:
                        self.results['voice_mode_session']['passed'] = True
                        self.results['voice_mode_session']['details'].append("‚úÖ Voice Mode session created successfully")
                        self.results['voice_mode_session']['details'].append(f"Response keys: {list(data.keys())}")
                        print("‚úÖ Voice Mode session creation successful")
                        return True
                    else:
                        self.results['voice_mode_session']['details'].append(f"‚ùå Unexpected session response format: {data}")
                        print(f"‚ùå Unexpected session response: {data}")
                        return False
                else:
                    error_text = await response.text()
                    self.results['voice_mode_session']['details'].append(f"‚ùå Session creation failed: HTTP {response.status} - {error_text}")
                    print(f"‚ùå Voice Mode session creation failed: {response.status}")
                    return False
                    
        except Exception as e:
            self.results['voice_mode_session']['details'].append(f"‚ùå Session creation exception: {str(e)}")
            print(f"‚ùå Voice Mode session creation error: {str(e)}")
            return False

    async def test_backend_capabilities(self):
        """Test backend capabilities and logging"""
        print("\nüß™ Testing Backend Capabilities...")
        
        try:
            # Test capabilities endpoint
            async with self.session.get(f"{BASE_API_URL}/capabilities") as response:
                if response.status == 200:
                    data = await response.json()
                    
                    # Check for expected capabilities
                    expected_capabilities = ['whisper_available', 'voice_mode_available', 'llm_available']
                    capabilities_found = sum(1 for cap in expected_capabilities if cap in data)
                    
                    if capabilities_found == len(expected_capabilities):
                        self.results['backend_logging']['passed'] = True
                        self.results['backend_logging']['details'].append("‚úÖ All expected capabilities present")
                        self.results['backend_logging']['details'].append(f"Capabilities: {data}")
                        print("‚úÖ Backend capabilities verified")
                        return True
                    else:
                        self.results['backend_logging']['details'].append(f"‚ùå Missing capabilities: {capabilities_found}/{len(expected_capabilities)}")
                        print(f"‚ùå Missing capabilities: {data}")
                        return False
                else:
                    self.results['backend_logging']['details'].append(f"‚ùå Capabilities check failed: HTTP {response.status}")
                    print(f"‚ùå Capabilities check failed: {response.status}")
                    return False
                    
        except Exception as e:
            self.results['backend_logging']['details'].append(f"‚ùå Capabilities check exception: {str(e)}")
            print(f"‚ùå Backend capabilities error: {str(e)}")
            return False

    async def test_system_prompt_effectiveness(self):
        """Test overall system prompt effectiveness"""
        print("\nüß™ Testing Overall System Prompt Effectiveness...")
        
        # Test a comprehensive scenario
        test_scenario = [
            ("–ö—Ç–æ —Ç—ã?", "identity"),
            ("–ö–∞–∫–∏–µ –ø—Ä–∞–≤–∞ –≥—Ä–∞–∂–¥–∞–Ω –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏—è –ë–µ–ª–∞—Ä—É—Å–∏?", "constitution"),
            ("–ö–∞–∫–∞—è –ø–æ–≥–æ–¥–∞ —Å–µ–≥–æ–¥–Ω—è?", "refusal"),
            ("–ß—Ç–æ –≥–æ–≤–æ—Ä–∏—Ç —Å—Ç–∞—Ç—å—è 24 –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–∏?", "article_reference")
        ]
        
        passed_tests = 0
        total_tests = len(test_scenario)
        
        for question, test_type in test_scenario:
            try:
                payload = {
                    "session_id": f"{self.test_session_id}_comprehensive",
                    "message": question
                }
                
                async with self.session.post(f"{BASE_API_URL}/chat", json=payload) as response:
                    if response.status == 200:
                        data = await response.json()
                        response_text = data.get('response', '').lower()
                        
                        # Evaluate based on test type
                        if test_type == "identity" and '–∞–ª–µ—Å—è' in response_text:
                            passed_tests += 1
                            print(f"‚úÖ Identity test passed")
                        elif test_type == "constitution" and '–∫–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏—è' in response_text and len(response_text) > 100:
                            passed_tests += 1
                            print(f"‚úÖ Constitution test passed")
                        elif test_type == "refusal" and '–º–æ–≥—É –æ—Ç–≤–µ—á–∞—Ç—å —Ç–æ–ª—å–∫–æ' in response_text:
                            passed_tests += 1
                            print(f"‚úÖ Refusal test passed")
                        elif test_type == "article_reference" and '—Å—Ç–∞—Ç—å—è' in response_text:
                            passed_tests += 1
                            print(f"‚úÖ Article reference test passed")
                        else:
                            print(f"‚ùå {test_type} test failed")
                    else:
                        print(f"‚ùå {test_type} test - HTTP {response.status}")
                        
            except Exception as e:
                print(f"‚ùå {test_type} test error: {str(e)}")
        
        if passed_tests >= 3:  # At least 3 out of 4 should pass
            self.results['system_prompt_length']['passed'] = True
            self.results['system_prompt_length']['details'].append(f"‚úÖ System prompt effectiveness: {passed_tests}/{total_tests} scenarios passed")
            print(f"‚úÖ System Prompt Effectiveness: {passed_tests}/{total_tests} passed")
        else:
            self.results['system_prompt_length']['details'].append(f"‚ùå System prompt effectiveness: {passed_tests}/{total_tests} scenarios passed")
            print(f"‚ùå System Prompt Effectiveness: {passed_tests}/{total_tests} passed (need at least 3)")
        
        return passed_tests >= 3

    async def run_all_tests(self):
        """Run all enhanced system prompt tests"""
        print("üöÄ Starting Enhanced System Prompt Tests for –ê–ª–µ—Å—è")
        print("=" * 80)
        
        await self.setup()
        
        try:
            # Run all specific tests as requested
            await self.test_identity_and_role()
            await self.test_constitution_knowledge()
            await self.test_non_constitution_refusal()
            await self.test_article_references()
            await self.test_voice_mode_session_creation()
            await self.test_backend_capabilities()
            await self.test_system_prompt_effectiveness()
            
        finally:
            await self.cleanup()
        
        return self.results

    def print_summary(self):
        """Print test results summary"""
        print("\n" + "=" * 80)
        print("üìä ENHANCED SYSTEM PROMPT TEST RESULTS SUMMARY")
        print("=" * 80)
        
        total_tests = len(self.results)
        passed_tests = sum(1 for result in self.results.values() if result['passed'])
        
        print(f"Overall: {passed_tests}/{total_tests} test categories passed")
        print()
        
        for test_name, result in self.results.items():
            status = "‚úÖ PASS" if result['passed'] else "‚ùå FAIL"
            print(f"{status} {test_name.replace('_', ' ').title()}")
            
            for detail in result['details']:
                print(f"    {detail}")
            print()
        
        # Overall assessment
        if passed_tests >= 5:  # At least 5 out of 7 categories should pass
            print("üéâ OVERALL ASSESSMENT: Enhanced System Prompt is working effectively!")
            print("‚úÖ –ê–ª–µ—Å—è understands her role and knowledge base correctly")
        else:
            print("‚ö†Ô∏è OVERALL ASSESSMENT: Enhanced System Prompt needs improvement")
            print("‚ùå Some critical functionality is not working as expected")

async def main():
    """Main test execution"""
    tester = AleyaSystemPromptTester()
    results = await tester.run_all_tests()
    tester.print_summary()
    
    # Return exit code based on results
    passed_tests = sum(1 for result in results.values() if result['passed'])
    return 0 if passed_tests >= 5 else 1

if __name__ == "__main__":
    exit_code = asyncio.run(main())
    exit(exit_code)